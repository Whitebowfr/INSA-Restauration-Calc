{"ast":null,"code":"export function getDaysTillEndOfMonth(type, includesVacations) {\n  let dateToday = new Date();\n  dateToday.setDate(dateToday.getDate() + 1);\n  let endDate = new Date(dateToday.getFullYear(), dateToday.getMonth() + 1, 0);\n  endDate.setDate(endDate.getDate() + 1);\n  let total = 0;\n  while (dateToday <= endDate) {\n    if (dateToday.getDay() !== 0 && dateToday.getDay() !== 6) {\n      if (type === \"week\") {\n        total += includesVacations ? 1 : !checkForVacation(dateToday);\n      }\n    } else if (type === \"we\") {\n      total += includesVacations ? 1 : !checkForVacation(dateToday);\n    }\n    dateToday.setDate(dateToday.getDate() + 1);\n  }\n  return total;\n}\n\n// Les journées sont exclusives (ex. pour les vacances du 16 décembre, la journée du 16 est comptée comme ouvrée)\nconst vacations = [\n// Automne\n[1666994400000, 1667689200000],\n// Noel\n[1671231600000, 1672614000000],\n// Hiver\n[1676070000000, 1676761200000],\n// Printemps\n[1680904800000, 1682200800000],\n// Grandes vacances\n[1684533600000, 1694988000000]];\nexport function checkForVacation(date) {\n  let dateTimeStamp = date.getTime();\n  let flag = false;\n  vacations.forEach(arr => {\n    if (dateTimeStamp > arr[0] && dateTimeStamp < arr[1]) flag = true;\n  });\n  return flag;\n}\nexport function isAWeekDay(date) {\n  return !(date.getDay() === 6 || date.getDay() === 1);\n}\nexport function hasHourPassed(date, hour) {\n  let datee = new Date(date);\n  if (datee.getHours() > parseInt(hour.split(\":\")[0])) {\n    return true;\n  } else if (datee.getHours() === parseInt(hour.split(\":\")[0]) && datee.getMinutes() > parseInt(hour.split(\":\")[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}","map":{"version":3,"names":["getDaysTillEndOfMonth","type","includesVacations","dateToday","Date","setDate","getDate","endDate","getFullYear","getMonth","total","getDay","checkForVacation","vacations","date","dateTimeStamp","getTime","flag","forEach","arr","isAWeekDay","hasHourPassed","hour","datee","getHours","parseInt","split","getMinutes"],"sources":["D:/dev/Rest_Calc/src/utils/calendar.js"],"sourcesContent":["export function getDaysTillEndOfMonth(type, includesVacations) {\r\n    let dateToday = new Date()\r\n    dateToday.setDate(dateToday.getDate() + 1)\r\n    let endDate = new Date(dateToday.getFullYear(), dateToday.getMonth() + 1, 0)\r\n    endDate.setDate(endDate.getDate() + 1)\r\n    let total = 0\r\n    while (dateToday <= endDate) {\r\n        if (dateToday.getDay() !== 0 && dateToday.getDay() !== 6) {\r\n            if (type === \"week\") {\r\n                total += (includesVacations ? 1 : !checkForVacation(dateToday))\r\n            }\r\n        } else if (type === \"we\") {\r\n            total += (includesVacations ? 1 : !checkForVacation(dateToday))\r\n        }\r\n        dateToday.setDate(dateToday.getDate() + 1)\r\n    }\r\n    return total\r\n}\r\n\r\n// Les journées sont exclusives (ex. pour les vacances du 16 décembre, la journée du 16 est comptée comme ouvrée)\r\nconst vacations = [\r\n    // Automne\r\n    [1666994400000, 1667689200000],\r\n    // Noel\r\n    [1671231600000, 1672614000000],\r\n    // Hiver\r\n    [1676070000000, 1676761200000],\r\n    // Printemps\r\n    [1680904800000, 1682200800000],\r\n    // Grandes vacances\r\n    [1684533600000, 1694988000000]\r\n]\r\n\r\nexport function checkForVacation(date) {\r\n    let dateTimeStamp = date.getTime()\r\n    let flag = false\r\n    vacations.forEach(arr => {\r\n        if (dateTimeStamp > arr[0] && dateTimeStamp < arr[1]) flag = true\r\n    })\r\n    return flag\r\n}\r\n\r\nexport function isAWeekDay(date) {\r\n    return !(date.getDay() === 6 || date.getDay() === 1)\r\n}\r\n\r\nexport function hasHourPassed(date, hour) {\r\n    let datee = new Date(date)\r\n    if (datee.getHours() > parseInt(hour.split(\":\")[0])) {\r\n        return true\r\n    } else if (datee.getHours() === parseInt(hour.split(\":\")[0]) && datee.getMinutes() > parseInt(hour.split(\":\")[1])) {\r\n       return true\r\n   } else {\r\n       return false\r\n   }\r\n}"],"mappings":"AAAA,OAAO,SAASA,qBAAqB,CAACC,IAAI,EAAEC,iBAAiB,EAAE;EAC3D,IAAIC,SAAS,GAAG,IAAIC,IAAI,EAAE;EAC1BD,SAAS,CAACE,OAAO,CAACF,SAAS,CAACG,OAAO,EAAE,GAAG,CAAC,CAAC;EAC1C,IAAIC,OAAO,GAAG,IAAIH,IAAI,CAACD,SAAS,CAACK,WAAW,EAAE,EAAEL,SAAS,CAACM,QAAQ,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC;EAC5EF,OAAO,CAACF,OAAO,CAACE,OAAO,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;EACtC,IAAII,KAAK,GAAG,CAAC;EACb,OAAOP,SAAS,IAAII,OAAO,EAAE;IACzB,IAAIJ,SAAS,CAACQ,MAAM,EAAE,KAAK,CAAC,IAAIR,SAAS,CAACQ,MAAM,EAAE,KAAK,CAAC,EAAE;MACtD,IAAIV,IAAI,KAAK,MAAM,EAAE;QACjBS,KAAK,IAAKR,iBAAiB,GAAG,CAAC,GAAG,CAACU,gBAAgB,CAACT,SAAS,CAAE;MACnE;IACJ,CAAC,MAAM,IAAIF,IAAI,KAAK,IAAI,EAAE;MACtBS,KAAK,IAAKR,iBAAiB,GAAG,CAAC,GAAG,CAACU,gBAAgB,CAACT,SAAS,CAAE;IACnE;IACAA,SAAS,CAACE,OAAO,CAACF,SAAS,CAACG,OAAO,EAAE,GAAG,CAAC,CAAC;EAC9C;EACA,OAAOI,KAAK;AAChB;;AAEA;AACA,MAAMG,SAAS,GAAG;AACd;AACA,CAAC,aAAa,EAAE,aAAa,CAAC;AAC9B;AACA,CAAC,aAAa,EAAE,aAAa,CAAC;AAC9B;AACA,CAAC,aAAa,EAAE,aAAa,CAAC;AAC9B;AACA,CAAC,aAAa,EAAE,aAAa,CAAC;AAC9B;AACA,CAAC,aAAa,EAAE,aAAa,CAAC,CACjC;AAED,OAAO,SAASD,gBAAgB,CAACE,IAAI,EAAE;EACnC,IAAIC,aAAa,GAAGD,IAAI,CAACE,OAAO,EAAE;EAClC,IAAIC,IAAI,GAAG,KAAK;EAChBJ,SAAS,CAACK,OAAO,CAACC,GAAG,IAAI;IACrB,IAAIJ,aAAa,GAAGI,GAAG,CAAC,CAAC,CAAC,IAAIJ,aAAa,GAAGI,GAAG,CAAC,CAAC,CAAC,EAAEF,IAAI,GAAG,IAAI;EACrE,CAAC,CAAC;EACF,OAAOA,IAAI;AACf;AAEA,OAAO,SAASG,UAAU,CAACN,IAAI,EAAE;EAC7B,OAAO,EAAEA,IAAI,CAACH,MAAM,EAAE,KAAK,CAAC,IAAIG,IAAI,CAACH,MAAM,EAAE,KAAK,CAAC,CAAC;AACxD;AAEA,OAAO,SAASU,aAAa,CAACP,IAAI,EAAEQ,IAAI,EAAE;EACtC,IAAIC,KAAK,GAAG,IAAInB,IAAI,CAACU,IAAI,CAAC;EAC1B,IAAIS,KAAK,CAACC,QAAQ,EAAE,GAAGC,QAAQ,CAACH,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IACjD,OAAO,IAAI;EACf,CAAC,MAAM,IAAIH,KAAK,CAACC,QAAQ,EAAE,KAAKC,QAAQ,CAACH,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIH,KAAK,CAACI,UAAU,EAAE,GAAGF,QAAQ,CAACH,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IAChH,OAAO,IAAI;EACf,CAAC,MAAM;IACH,OAAO,KAAK;EAChB;AACH"},"metadata":{},"sourceType":"module"}